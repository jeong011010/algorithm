## floyd_warshall algorithm (플로이드-와샬 알고리즘)
- 그래프 상에서 '모든 정점'에서 '모든 정점'으로의 최단 거리를 구할 때 사용.
- 거쳐가는 정점을 기준으로 알고리즘 수행.


### 알고리즘 구조
- 우선 이해를 위해 그래프를 표로 변환한다.
- x, y축을 정점의 개수만큼 쓴 뒤, 각 칸에 (지금 당장 노선 한개로 이어지는 경로) 정점에서 정점으로 가는 비용으로 채운다. (나머지는 비워둔다, x==y인 경우 0)
- 그 후, 작은 정점부터 시작하여
  - 해당 정점을 거쳐가는 노선의 비용이 해당 칸의 비용보다 적거나, 해당 칸이 비어있을 경우 두 경로의 비용을 더하여 채워준다. 

아래는 [백준 1389](https://www.acmicpc.net/status?user_id=jeong011010&problem_id=1389&from_mine=1) 문제에서 사용한 floyd_warshall 함수이다. 
```C
void floyd_warshall() {
	for (int k = 1; k <= n; k++) //작은 정점부터 시작
		for (int i = 1; i <= n; i++) //x축
			for (int j = 1; j <= n; j++)  //y축
				if (i != j && graph[k][j] && graph[i][k]) { //x와 y축이 다르며, 둘다 1인 경우
					if (graph[i][j] == 0) 
						graph[i][j] = graph[i][k] + graph[k][j]; //비어있다면 두개의 비용을 더해 채워준다.
					else
						graph[i][j] = min(graph[i][j], graph[i][k] + graph[k][j]); //채워져있다면 두개의 비용을 더한것과 채워져있는 것을 비교하여 적은것으로 채운다.
				}
}
```

## 정리
해당 알고리즘을 활용할 수 있는 경우는
- '모든 정점'에서 시작해서 '모든 정점'으로 가는 최단 경로를 알아내야 할 때.

시간 복잡도 && 공간 복잡도
- 정점의 개수 N만큼 반복분이 3중으로 수행되고 있기 때문에 O(pow(V,3))의 시간 복잡도를 갖는다.
- 간선들의 정보를 N∗N 크기의 인접행렬에 담았기 때문에 O(pow(V,2))의 공간 복잡도를 갖는다.
